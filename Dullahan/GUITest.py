'''
This file is used to test individual GUI elements as generated by RACC as to efficiently generate a sufficient GUI for parameter selection in Dullahan
'''


import numpy as np
import math

import warnings
from enum import Enum

from mayavi import mlab
from mayavi.core.ui.api import MayaviScene, MlabSceneModel, \
        SceneEditor
from tvtk.util import ctf

from skimage import data, io

#import matplotlib.pyplot as plt
from matplotlib.backends.qt_compat import QtCore, QtWidgets, is_pyqt5
if is_pyqt5():
    from matplotlib.backends.backend_qt5agg import (FigureCanvas, NavigationToolbar2QT as NavigationToolbar)
else:
    from matplotlib.backends.backend_qt4agg import (
        FigureCanvas, NavigationToolbar2QT as NavigationToolbar)
from matplotlib.figure import Figure


from PyQt5.QtCore import (Qt, QThread, QObject, pyqtSignal, pyqtSlot)
from PyQt5 import QtGui
from PyQt5.QtWidgets import (QApplication, QCheckBox, QComboBox,
        QDialog, QGridLayout, QGroupBox, QHBoxLayout, QLabel, QLineEdit,
        QProgressBar, QPushButton,  QSlider, QStyleFactory, QWidget,
        QFileDialog, QMessageBox, QVBoxLayout)

from traits.api import HasTraits, Instance, on_trait_change, Range
from traitsui.api import View, Item, HGroup

#https://stackoverflow.com/questions/6783194/background-thread-with-qthread-in-pyqt
class Worker(QObject):
    finished = pyqtSignal()
    processThread = pyqtSignal()


    @pyqtSlot()
    def procCounter(self): # A slot takes no params
#        for i in range(1, 100):
#            time.sleep(1)
        self.processThread.emit()

        self.finished.emit()


################################################################################
# The actual visualization
class VisualizationInput(HasTraits):
    scene = Instance(MlabSceneModel, ())
    scene.background = (0, 0, 0)  # np.array([0.0,0.0,0.0])
    alpha = Range(0.0, 0.2, 0.1)
    scale = Range(0.0, 20, 10)
    fullStack3D = None
    RGBcolorm = []
    maxVal = 0
    vol = None

    @on_trait_change('fullStack3D, scene.activated, RGBcolorm')  # 'scene.activated')
    def update_plot(self):
        # This function is called when the view is opened. We don't
        # populate the scene when the view is not yet open, as some
        # VTK features require a GLContext.

        # We can do normal mlab calls on the embedded scene.
        #        self.scene.mlab.test_points3d()
        if (len(self.RGBcolorm) == 0):
            self.RGBcolorm = self.generateColormap()
            self.maxVal = len(self.RGBcolorm)

        try:
            print("\nself.fullStack3D.shape ", self.fullStack3D.shape)

            #            mlab.figure(bgcolor = (0,0,0), fgcolor = (1, 1, 1))

            self.vol = mlab.pipeline.volume(mlab.pipeline.scalar_field(self.fullStack3D))  # , vmin=0.0, vmax=0.5)
            self.vol.volume.scale = np.array([self.scale, 1.0, 1.0])
            self.vol._volume_property.shade = False
            self.vol._volume_property.interpolation_type = 'nearest'
            # vol._volume_mapper = tvtk.FixedPointVolumeRayCastMapper()
            # vol._volume_mapper.on_trait_change(vol.render)
            self.vol.render()

            c = ctf.save_ctfs(self.vol._volume_property)
            # print( c)
            c['range'] = (0, self.maxVal)
            c['alpha'] = [[0.0, 0.0], [1.0, self.alpha],
                          [self.maxVal, self.alpha]]  # [[0.0, 0.1], [1.0, 0.1], [maxVal-1, 0.1], [maxVal, 0.1]]
            c[
                'rgb'] = self.RGBcolorm  # [[0.0, 0.0, 0.0, 0.0], [maxVal/4, 1.0, 0.0, 0.0], [maxVal/2, 1.0, 1.0, 0.0], [maxVal/4*3, 0.0, 1.0, 0.0], [maxVal, 0.0, 0.0, 0.0]]
            # print( c)
            # c['rgb'] =
            ctf.load_ctfs(c, self.vol._volume_property)
            # Update the shadow LUT of the volume module.
            self.vol.update_ctf = True

            #            mlab.view(132, 54, 45, [21, 20, 21.5])
            #            mlab.show()
            self.scene.background = (0, 0, 0)

            print("3D stack viz")
        except:
            print("\nNo stack yet")

    @on_trait_change('scale')  # 'scene.activated')
    def update_plot2(self):
        self.vol.volume.scale = np.array([self.scale, 1.0, 1.0])

    @on_trait_change('alpha')  # 'scene.activated')
    def update_plot3(self):
        c = ctf.save_ctfs(self.vol._volume_property)
        # print( c)
        #        c['range'] = (0, self.maxVal)
        c['alpha'] = [[0.0, 0.0], [1.0, self.alpha],
                      [self.maxVal, self.alpha]]  # [[0.0, 0.1], [1.0, 0.1], [maxVal-1, 0.1], [maxVal, 0.1]]
        #        c['rgb'] = self.RGBcolorm#[[0.0, 0.0, 0.0, 0.0], [maxVal/4, 1.0, 0.0, 0.0], [maxVal/2, 1.0, 1.0, 0.0], [maxVal/4*3, 0.0, 1.0, 0.0], [maxVal, 0.0, 0.0, 0.0]]
        # print( c)
        # c['rgb'] =
        ctf.load_ctfs(c, self.vol._volume_property)
        # Update the shadow LUT of the volume module.
        self.vol.update_ctf = True

    def generateColormap(self, bitsPerChannel=6):
        maxVal = 2 ** bitsPerChannel
        colormap = []

        chan1Val = 0
        chan2Val = 0
        for i in range(0, maxVal * maxVal):
            if (chan1Val == maxVal):
                chan2Val += 1
                chan1Val = 0

            colormap.append([i, chan1Val / maxVal, chan2Val / maxVal, 0.0])
            chan1Val += 1

        return colormap

    # the layout of the dialog screated
    view = View(Item('scene', editor=SceneEditor(scene_class=MayaviScene),
                     height=300, width=490, show_label=False), HGroup(
        '_', 'alpha', 'scale',
    ), resizable=True
                )


################################################################################
# The QWidget containing the visualization, this is pure PyQt4 code.
class MayaviQWidget(QWidget):
    def __init__(self, parent=None):
        QWidget.__init__(self, parent)
        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.layout.setSpacing(0)
        self.visualization = VisualizationInput()

        # If you want to debug, beware that you need to remove the Qt
        # input hook.
        # QtCore.pyqtRemoveInputHook()
        # import pdb ; pdb.set_trace()
        # QtCore.pyqtRestoreInputHook()
        # The edit_traits call will generate the widget to embed.
        self.ui = self.visualization.edit_traits(parent=self, kind='subpanel').control
        self.layout.addWidget(self.ui)
        self.ui.setParent(self)

    def refresh(self):
        # The edit_traits call will generate the widget to embed.
        self.layout.removeWidget(self.ui)
        self.ui = self.visualization.edit_traits(parent=self, kind='subpanel').control
        self.layout.addWidget(self.ui)
        self.ui.setParent(self)
